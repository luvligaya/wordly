# model_trainer.py
"""
This script is responsible for training a machine learning model to classify valid country names 
using a dataset of real countries and a set of synthetic negative examples. 

The workflow includes:
1. **Generating Training Data**: Positive examples are taken from the real country names. Negative examples are generated by creating fictional country names, invalid entries (cities, common objects), and random character sequences.
2. **Model Training**: The data is split into training and test sets. A Naive Bayes classifier with a TF-IDF feature extraction method is used to train the model.
3. **Model Evaluation**: The model's accuracy, precision, recall, F1 score, and confusion matrix are printed to assess performance.
4. **Model Saving**: The trained model is saved to a file using the `joblib` library for future use.

### Functions:
- `generate_training_data(countries_data)`: Generates a labeled dataset combining valid country names, fake country names, invalid entries, and random sequences.
- `train_country_classifier()`: Trains a Naive Bayes model using the generated training data, evaluates it, and saves the trained model to a file.

### Libraries Used:
- **joblib**: For saving the trained model.
- **pandas**: For creating and manipulating the training data.
- **scikit-learn**: For machine learning tasks, including feature extraction (TF-IDF), model training (Naive Bayes), evaluation, and splitting data into train and test sets.

### Execution Flow:
1. **Generate Training Data**: A combination of real and synthetic data is created to train the model.
2. **Train Model**: The Naive Bayes classifier is trained on the data using a TF-IDF vectorizer.
3. **Evaluate Model**: Model evaluation metrics like accuracy, precision, recall, and F1 score are computed and displayed.
4. **Save Model**: The model is saved to a file for future use in classifying country names.

This model will be used in subsequent applications to classify and verify country names based on input.
"""

import joblib
import random
import string
import pandas as pd
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.model_selection import train_test_split
from sklearn.naive_bayes import MultinomialNB
from sklearn.metrics import accuracy_score, precision_recall_fscore_support, confusion_matrix
from sklearn.pipeline import Pipeline

from countries_data import CountriesDataManager

def generate_training_data(countries_data):
    """Create a dataset for training the NLP classifier"""
    # Create positive examples (real countries)
    positive_examples = pd.DataFrame({
        'text': countries_data,
        'is_country': 1
    })
    
    # Create negative examples (non-countries or invalid entries)
    # 1. Generate fictional country names
    fake_countries = [
        "northlandia", "westeros", "oceania", "panem", "atlantis", "narnia",
        "wakanda", "gondor", "mordor", "asgard", "latveria", "genosha",
        "krypton", "metropolis", "gotham", "smallville", "tamriel", "skyrim",
        "cyrodiil", "hyrule", "mushroom kingdom", "johto", "kanto", "alola"
    ]
    
    # 2. Generate invalid entries like numbers, cities, etc.
    invalid_entries = [
        "new york", "tokyo", "london", "paris", "berlin", "moscow", "rome",
        "madrid", "beijing", "sydney", "mumbai", "toronto", "chicago",
        "los angeles", "seattle", "car", "computer", "phone", "mountain",
        "ocean", "river", "desert", "forest", "twelve", "ninety nine"
    ]
    
    # 3. Generate some random character sequences
    random_entries = [
        ''.join(random.choices(string.ascii_lowercase, k=random.randint(4, 10)))
        for _ in range(20)
    ]
    
    # Combine all negative examples
    negative_examples = pd.DataFrame({
        'text': fake_countries + invalid_entries + random_entries,
        'is_country': 0
    })
    
    # Combine positive and negative examples
    training_data = pd.concat([positive_examples, negative_examples], ignore_index=True)
    
    # Shuffle the data
    return training_data.sample(frac=1).reset_index(drop=True)

def train_country_classifier():
    """Train and save a Naive Bayes classifier to identify valid country names"""
    # Get countries data
    data_manager = CountriesDataManager()
    countries_data = data_manager.get_all_countries()
    
    # Generate training data
    data = generate_training_data(countries_data)
    
    # Split into features and target
    X = data['text']
    y = data['is_country']
    
    # Split into training and testing sets
    X_train, X_test, y_train, y_test = train_test_split(
        X, y, test_size=0.2, random_state=42
    )
    
    # Create a pipeline with TF-IDF and Naive Bayes
    pipeline = Pipeline([
        ('tfidf', TfidfVectorizer(ngram_range=(1, 2))),
        ('clf', MultinomialNB())
    ])
    
    # Train the model
    print("Training country classifier model...")
    pipeline.fit(X_train, y_train)
    
    # Evaluate the model
    print("Evaluating model...")
    y_pred = pipeline.predict(X_test)
    accuracy = accuracy_score(y_test, y_pred)
    precision, recall, f1, _ = precision_recall_fscore_support(
        y_test, y_pred, average='binary'
    )
    conf_matrix = confusion_matrix(y_test, y_pred)
    
    print(f"Model Evaluation:")
    print(f"Accuracy: {accuracy:.2f}")
    print(f"Precision: {precision:.2f}")
    print(f"Recall: {recall:.2f}")
    print(f"F1 Score: {f1:.2f}")
    print(f"Confusion Matrix:\n{conf_matrix}")
    
    # Save the model
    print("Saving model to 'country_classifier_model.joblib'")
    joblib.dump(pipeline, 'country_classifier_model.joblib')
    print("Model saved successfully!")

if __name__ == "__main__":
    train_country_classifier()